---
name: audit
description: 对当前项目进行全面代码审计 检查架构问题/死代码/重复实现/耦合度/泛用性 当需要对系统进行overview 或者修复某个异常时读取该文档
user_invocable: true
---

# 代码审计

执行此技能时 对当前项目进行全面审计 需要遵循以下几点
- 预览全部代码 并且尽可能多地发现问题
- 如果没发现任何问题 则直接报告未发现问题即可
- 如果无法预览全部代码 则告知用户你检查了哪些模块

## 审计流程

### Step 1: 启用 code-RAG
先启用 skill:code-RAG，然后执行 index_codebase 确保索引最新。

### Step 2: 并行扫描

**Agent A — 死代码分析:**
- 找出所有已导出但未被调用的函数/类型/常量
- 找出所有已定义但未被 import 的文件
- 分语言检查: 各语言各自的未使用导出
- 检查没有消费者的 或者在系统中不会发挥作用的代码

**Agent B — 重复实现检测:**
- 搜索功能相似但在不同位置实现的代码
- 搜索重复定义的常量/配置值
- 搜索相似的数据结构定义
- 标注哪些应该合并为共享模块
- 找到通过少量改装即可兼并更多内容的模块

**Agent C — 耦合度分析:**
- 检查依赖方向是否合规(逻辑层不依赖渲染/UI/平台层)
- 检查模块间是否通过接口通信还是直接访问内部实现
- 检查是否存在全局可变状态跨模块共享
- 标注违规的依赖关系

**Agent D — 泛用性检查:**
- 找出硬编码的实体/对象构造(非通过工厂/配置/组件系统)
- 找出魔法数字和字符串字面量
- 找出只适用于特定案例的实现(应该泛化的代码)
- 检查测试/调试代码是否使用了与正式代码不同的构建路径
- 应该尽可能使用依赖注入便于模块化和调试

**Agent E — 优化建议:**
- 检查是否有成熟库可以替代目前的自行实现方案
- 检查算法复杂度是否合理
- 检查跨语言调用是否可以批量化
- 检查数据传输是否有不必要的序列化/反序列化
- 在性能受限设备上是否可以流畅运行
- 是否有更好的实现方案 可以带来更高的性能提升

### Step 3: 汇总报告

在 `.claude/docs/audit/` 下新建一个文件夹 将所有agent的结果汇总到其中的 `main-report.md` 格式:

```markdown
# 审计报告 — [项目名] — [日期]

## 摘要
- 扫描文件数: X
- 发现问题数: X

## 问题列表

### 1. 死代码
| 文件 | 符号 | 类型 | 状态 |
|------|------|------|------|

### 2. 重复实现
| 位置A | 位置B | 相似度 | 建议 |
|-------|-------|--------|------|

### 3. 耦合问题
| 模块 | 违规依赖 | 严重度 | 建议 |
|------|----------|--------|------|

### 4. 泛用性问题
| 文件 | 问题 | 建议 |
|------|------|------|

### 5. 优化建议
| 文件 | 当前实现 | 建议方案 |
|------|----------|----------|

## 实现方案

## 其他说明

```

### Step 4: 用户确认

将报告展示给用户 等待确认后再执行修复

### Step 5: 修复时

1. 运行index_codebase更新索引
2. 先不要运行add_knowledge 而是将修复方案详细记录到fix-Rx.md作为临时存储
3. 启动不超过5个subagent进行并行修复
4. 根据用户反馈 触发不同的动作
   - 如果用户反馈某条修复无效
     1. 撤销这一条修改的代码 防止代码污染
     2. 标记这个修复是无效的 防止别的agent再从这个角度进行修复
     3. 进入深度修复模式
   - 如果用户确认改动产生了影响但没有修复异常 进入深度修复模式 将其加入影响因素 辅助后续的判断

## 深度修复步骤
1. 再次探索这条修复相关代码 找出相关的模块
2. 从尽可能多的角度再次分析问题 列出所有可能的原因
3. 新增一个bug-x.md 将这个异常所有的相关内容存入 包括
   - 用户描述
   - 涉及模块/文件清单
   - 修复笔记
   - 有效影响因素
   - 无效修复方案
4. 深度修复前在本地创建一个新的git bug-fix分支
4. 深度修复时 添加详细的日志 并且要求用户返回给你以便排查问题
5. 进行一次深度修复后
   1. 调用skill:test对相关模块进行检测 确保运行正常
   2. 在本地新建一个commit 用一句话描述做了什么修改
6. 深度修复被用户确认效果后 做以下几件事
   1. 检查当前分支的代码是否符合上述审计标准
   2. 如果符合 将分支merge到支出的分支
   3. 在exp.md中写入修复经验
   4. 调用add_knowledge记录修复经验

## 重要约束
- 审计阶段只读不写 — 不修改任何代码
- 所有建议必须具体到文件和行号
- 优先级排序: 架构问题 > 重复代码 > 死代码 > 优化
- 报告使用中文